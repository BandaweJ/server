/* eslint-disable prettier/prettier */
import { EnrolEntity } from 'src/enrolment/entities/enrol.entity';
import { BalancesEntity } from 'src/finance/entities/balances.entity';
import { BillsEntity } from 'src/finance/entities/bills.entity';
import { StudentsEntity } from 'src/profiles/entities/students.entity';
import {
  Check,
  Column,
  CreateDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  OneToMany,
  OneToOne,
  PrimaryGeneratedColumn,
} from 'typeorm';
import { InvoiceStatus } from 'src/finance/models/invoice-status.enum';
import { ReceiptInvoiceAllocationEntity } from './receipt-invoice-allocation.entity';
import { ExemptionEntity } from 'src/exemptions/entities/exemptions.entity';
import { CreditInvoiceAllocationEntity } from './credit-invoice-allocation.entity'; // ADD THIS IMPORT

@Entity('invoice')
@Check(`balance >= 0 OR "isVoided" = true OR "isLegacy" = true`)
@Check(`"amountPaidOnInvoice" >= 0`)
@Check(`"totalBill" >= 0`)
@Check(`"exemptedAmount" >= 0`)
export class InvoiceEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true })
  invoiceNumber: string;

  @Column({ type: 'timestamp' })
  invoiceDate: Date;

  @Column()
  invoiceDueDate: Date;

  @Column({
    type: 'decimal',
    precision: 10,
    scale: 2,
    comment: 'Balance cannot be negative for active invoices (enforced by database constraint)',
  })
  balance: number;

  @Column({
    type: 'decimal',
    precision: 10,
    scale: 2,
    comment:
      '(total of all the bills) The total amount the student is being billed for the invoice. Cannot be negative (enforced by database constraint)',
  })
  totalBill: number;

  @Column({
    type: 'decimal',
    precision: 10,
    scale: 2,
    default: 0.0,
    comment: 'Amount paid cannot be negative (enforced by database constraint)',
  })
  amountPaidOnInvoice: number; // Tracks how much has been paid directly towards THIS invoice

  @Column({ default: InvoiceStatus.Pending })
  status: InvoiceStatus; // The current status of THIS invoice

  @Column({
    type: 'decimal',
    precision: 10,
    scale: 2,
    default: 0.0,
    comment: 'Exempted amount cannot be negative (enforced by database constraint)',
  })
  exemptedAmount: number;

  // Fields for voiding - invoices should NOT be deleted, only voided
  @Column({ default: false })
  isVoided: boolean;

  @Column({ type: 'timestamp', nullable: true })
  voidedAt: Date;

  @Column({ nullable: true })
  voidedBy: string; // E.g., email or ID of the user who voided it

  // Legacy flag for historical invoices that may have data inconsistencies
  // Legacy invoices are exempt from balance constraints to allow for historical data
  @Column({ default: false })
  isLegacy: boolean;

  // @Column({ type: 'decimal', precision: 10, scale: 2 })
  // totalPayments: number;

  @ManyToOne(() => StudentsEntity, (student) => student.invoices)
  student: StudentsEntity;

  // One-to-One relationship with BalancesEntity

  @OneToOne(() => BalancesEntity, (balanceBfwd) => balanceBfwd.invoice)
  @JoinColumn({ name: 'balanceId' }) // Foreign key column in the invoices table
  balanceBfwd: BalancesEntity; //balance Bfwd if available (will eventually phase out)

  // One-to-One relationship with EnrolEntity
  @OneToOne(() => EnrolEntity, (enrol) => enrol.invoice)
  @JoinColumn({ name: 'enrolId' }) // Foreign key column in the invoices table
  enrol: EnrolEntity;

  @OneToMany(() => BillsEntity, (bill) => bill.invoice, {
    cascade: true, // Keep this if you want to save/update bills when saving/updating invoice
    onDelete: 'CASCADE', // THIS IS THE KEY ADDITION
  })
  bills: BillsEntity[];

  // Existing: One-to-many relationship with receipt allocations
  @OneToMany(
    () => ReceiptInvoiceAllocationEntity,
    (allocation) => allocation.invoice,
  )
  allocations: ReceiptInvoiceAllocationEntity[];

  // NEW: One-to-many relationship with credit allocations
  @OneToMany(
    () => CreditInvoiceAllocationEntity, // ADD THIS LINE
    (allocation) => allocation.invoice, // ADD THIS LINE
  )
  creditAllocations: CreditInvoiceAllocationEntity[]; // ADD THIS LINE

  // An invoice belongs to one exemption (the one applied to it)
  @ManyToOne(() => ExemptionEntity, (exemption) => exemption.invoices, {
    nullable: true, // An invoice might not have an exemption
    onDelete: 'NO ACTION', // If the exemption is deleted, set this foreign key to null
  })
  @JoinColumn({ name: 'exemptionId' }) // Foreign key column in the invoice table
  exemption: ExemptionEntity;

  // Constructor to initialize fields
  constructor() {
    // Note: invoiceNumber is now generated by PaymentService.generateInvoiceNumber()
    // and should be set before saving the entity
    
    // Explicitly set invoiceDate when creating new invoice entity
    // This ensures consistency even if the entity is not saved immediately
    if (!this.invoiceDate) {
      this.invoiceDate = new Date();
    }
    
    if (!this.invoiceDueDate) {
      // Assuming a due date of 30 days from creation
      this.invoiceDueDate = this.calculateDueDate(30);
    }
    if (
      this.amountPaidOnInvoice === undefined ||
      this.amountPaidOnInvoice === null
    ) {
      this.amountPaidOnInvoice = 0;
    }
    if (this.balance === undefined || this.balance === null) {
      // If totalBill is guaranteed to be set *before* saving, then this.balance = this.totalBill;
      // Otherwise, initialize to 0 and update balance/totalBill in your service logic.
      this.balance = 0; // Or better: this.totalBill - this.amountPaidOnInvoice; but totalBill might not be set yet.
    }
    if (!this.status) {
      // Initialize status for new invoices
      this.status = InvoiceStatus.Pending;
    }
  }


  private calculateDueDate(daysToAdd: number): Date {
    const currentDate = new Date();
    const futureDate = new Date(currentDate);
    futureDate.setDate(currentDate.getDate() + daysToAdd);
    return futureDate;
  }
}
